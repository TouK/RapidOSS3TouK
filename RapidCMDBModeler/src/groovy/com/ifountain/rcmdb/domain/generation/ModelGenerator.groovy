package com.ifountain.rcmdb.domain.generation

import com.ifountain.rcmdb.domain.constraints.KeyConstraint
import com.ifountain.rcmdb.domain.converter.DateConverter
import com.ifountain.rcmdb.domain.converter.RapidConvertUtils
import groovy.text.SimpleTemplateEngine
import model.Model
import model.ModelRelation
import org.codehaus.groovy.grails.validation.ConstrainedProperty

class ModelGenerator
{
    public static final String MODEL_FILE_DIR = "grails-app/domain";
    public static final String TEMPLATES_FILE_DIR = "grails-app/templates/groovy";
    public static final List DEFAULT_IMPORTS = ["com.ifountain.core.domain.annotations.*"];
    private static ModelGenerator generator;
    File wholeClasstemplateFile
    File autoGeneratedCodeTemplateFile;

    def engine;
    def wholeClassTemplate;
    def autoGeneratedCodeTemplate;
    def tempBaseDir;
    def workingBaseDir;
    File workingModelDir;
    File tempModelDir;
    private ModelGenerator()
    {
    }

    public static ModelGenerator getInstance()
    {
        if(!generator)
        {
            generator = new ModelGenerator();
        }
        return generator;
    }

    def initialize(String workingBaseDir, String tempBaseDir, String templateDir)
    {
        wholeClasstemplateFile = new File("$templateDir/${TEMPLATES_FILE_DIR}/DomainClassTemplate.txt".toString());
        autoGeneratedCodeTemplateFile = new File("$templateDir/${TEMPLATES_FILE_DIR}/AutoGeneratedCodeTemplate.txt".toString());
        engine = new SimpleTemplateEngine();
        wholeClassTemplate = engine.createTemplate(wholeClasstemplateFile);
        autoGeneratedCodeTemplate = engine.createTemplate(autoGeneratedCodeTemplateFile);
        this.tempBaseDir = tempBaseDir;
        this.workingBaseDir = workingBaseDir;
        workingModelDir = new File(workingBaseDir+"/"+ MODEL_FILE_DIR);
        tempModelDir = new File(tempBaseDir+"/"+ MODEL_FILE_DIR);
    }

    def generateModels(Collection models)
    {
        def modelMetaDatas = [:];
        models.each{
            modelMetaDatas[it.name] = new ModelMetaData(it);
        }
        validateModels(modelMetaDatas);
        createModelFiles(modelMetaDatas);
    }

    public File getGeneratedModelFile(String name)
    {
        return new File(tempModelDir.path + "/" + name + ".groovy");
    }
    public File getCurrentModelFile(String name)
    {
        return new File(workingModelDir.path + "/" + name + ".groovy");
    }

    def generateSingleModelFileWithoutValidation(Model model)
    {
        def modelMetaDatas = [:];
        modelMetaDatas[model.name] = new ModelMetaData(model);
        createModelFiles(modelMetaDatas);
    }

    private def createEmptyDependentClasses(model)
    {
        def modelsNeedsToBeCreated = [:]
        if(model.parentModel)
        {
            modelsNeedToBeCreated[]
            generateEmptyModel (model.parentModel);
        }
        model.fromRelations
    }

    def validateModels(modelMetaDatas)
    {
        modelMetaDatas.each{modelName,modelMetaData->
            def modelBean = modelMetaData.model; 
            if(!modelMetaData.masterDatasource && !modelBean.parentModel)
            {
                throw ModelGenerationException.masterDatasourceDoesnotExists(modelBean.name);
            }

            modelMetaData.datasourceConfiguration.each{dsName,dsConf->
                if(dsConf.keys.size() == 0)
                {
                    throw ModelGenerationException.noKeySpecifiedForDatasource(dsName, modelName);   
                }
            }
        }
    }

    def createModelFiles(modelMetaDatas)
    {
        workingModelDir.mkdirs();
        tempModelDir.mkdirs();

        
        modelMetaDatas.each {modelName,modelMetaData->
            Model model = modelMetaData.model;


            def bindings = ["model":modelMetaData];
            def autoGeneratedCode = autoGeneratedCodeTemplate.make(bindings).toString();
            def modelFileToBeGenerated =  getGeneratedModelFile(model.name);

            def currentModelFile =  new File(workingModelDir.path + "/" + model.name + ".groovy");
            if(!currentModelFile.exists())
            {
                bindings["DEFAULT_IMPORTS"] = DEFAULT_IMPORTS;
                bindings["AUTO_GENERATED_CODE"] = autoGeneratedCode;
               modelFileToBeGenerated.withWriter { w ->
                    def x = wholeClassTemplate.make(bindings);
                    x.writeTo(w);
                }

            }
            else
            {
                def modelText = ModelGenerationUtils.generateClassText(currentModelFile, model.name, model.parentModel?.name, autoGeneratedCode, DEFAULT_IMPORTS);
                modelFileToBeGenerated.setText(modelText);
            }
        }
    }


}

class ModelMetaData
{
    def datasourceConfiguration = [:];
    def masterDatasource;
    def hasMany = [:];
    def belongsTo = [];
    def mappedBy = [:];
    def propertyConfigurations = [:];
    def transientProps = [];
    def constraints = [:];
    def propertyList = [];
    def Model model;
    def numberOfDatasources
    def ModelMetaData(Model model)
    {
        this.model = model;
        createDatasourceConfiguration (model);
        processProperties(model);
        processRelations(model);
    }

    def createDatasourceConfiguration(Model model)
    {
        model.datasources.each{
            def dsConf = [:];
            def dsName = it.datasource.name;
            datasourceConfiguration[dsName] = dsConf;
            dsConf["master"] = it.master;
            if(it.master)
            {
                masterDatasource = dsConf;
            }

            def keys = [:];
            it.keyMappings.each{keyMapping->
                keys[keyMapping.property.name] = ["nameInDs":keyMapping.nameInDatasource?keyMapping.nameInDatasource:keyMapping.property.name];
            }
            dsConf["keys"] =  keys;
        }
    }

    def processProperties(Model model)
    {
        def masterKeyPropName = null;
        model.modelProperties.each{
            def generalPropConfig = [:];
            generalPropConfig["type"] = it.convertToRealType();
            generalPropConfig["name"] = it.name;
            propertyList += generalPropConfig;
            constraints[it.name] = [:];
            generalPropConfig["defaultValue"] = getDefaultValue(it);
            if(it.propertyDatasource != null && !it.propertyDatasource.master || it.propertySpecifyingDatasource != null)
            {
                transientProps += it.name;
                def federatedPropertyConfiguration = [:];
                federatedPropertyConfiguration["nameInDs"] =  it.nameInDatasource?it.nameInDatasource:it.name;
                if(it.propertyDatasource)
                {
                    federatedPropertyConfiguration["datasource"] =  it.propertyDatasource.datasource.name;
                }
                else
                {
                    federatedPropertyConfiguration["datasourceProperty"] =  it.propertySpecifyingDatasource.name;
                }
                federatedPropertyConfiguration["lazy"] = it.lazy;
                propertyConfigurations[it.name] = federatedPropertyConfiguration;
                constraints[it.name][ConstrainedProperty.BLANK_CONSTRAINT] = it.blank;
                constraints[it.name][ConstrainedProperty.NULLABLE_CONSTRAINT] = true;
            }
            else
            {
                if(!masterDatasource || !masterDatasource.keys.containsKey(it.name))
                {
                    constraints[it.name][ConstrainedProperty.BLANK_CONSTRAINT] = it.blank;
                    constraints[it.name][ConstrainedProperty.NULLABLE_CONSTRAINT] = true;
                }
                else
                {
                    constraints[it.name][ConstrainedProperty.BLANK_CONSTRAINT] = false;
                    constraints[it.name][ConstrainedProperty.NULLABLE_CONSTRAINT] = false;
                    masterKeyPropName = it.name;
                }
            }
        }
        if(masterKeyPropName)
        {
            def uniqueKeys = [];
            masterDatasource.keys.each{key,value->
                if(key != masterKeyPropName)
                {
                    uniqueKeys += key;
                }
            }
            constraints[masterKeyPropName][KeyConstraint.KEY_CONSTRAINT] = uniqueKeys;
        }
    }

    private def processRelation(cardinality, oppositeCardinality, name, oppositeName, oppositeType, isSecond)
    {
        if(cardinality == ModelRelation.ONE && oppositeCardinality == ModelRelation.MANY)
        {
            hasMany[name] = oppositeType;
        }
        else if(cardinality == ModelRelation.MANY && oppositeCardinality == ModelRelation.ONE || cardinality == ModelRelation.ONE && oppositeCardinality == ModelRelation.ONE)
        {
            constraints[name] = [nullable:true];
            def generalPropConfig = [:];
            generalPropConfig["type"] = oppositeType;
            generalPropConfig["name"] = name;
            generalPropConfig["defaultValue"] = null;
            propertyList += generalPropConfig;
        }
        else if(cardinality == ModelRelation.MANY && oppositeCardinality == ModelRelation.MANY)
        {
            if(isSecond)
            {
                if(!belongsTo.contains(oppositeType))
                {
                    belongsTo += oppositeType;
                }
            }
            hasMany[name] = oppositeType;
        }
        mappedBy[name] = oppositeName;
    }
    
    def processRelations(Model model)
    {
        model.fromRelations.each{
            processRelation(it.firstCardinality,it.secondCardinality,it.firstName,it.secondName,it.secondModel.name, false);
        }
        model.toRelations.each{
            processRelation(it.secondCardinality,it.firstCardinality,it.secondName,it.firstName,it.firstModel.name, true);
        }
    }

    def getDefaultValue(modelProperty)
    {
        def defaultVlue = modelProperty.defaultValue == ""?null:modelProperty.defaultValue;
        if(modelProperty.type == model.ModelProperty.stringType)
        {
            return defaultVlue?"\"${defaultVlue}\"":"\"\"";
        }
        else if(modelProperty.type == model.ModelProperty.numberType || modelProperty.type == model.ModelProperty.floatType)
        {
            return defaultVlue?"$defaultVlue":"0";
        }
        else if(modelProperty.type == model.ModelProperty.dateType)
        {
            DateConverter converter = RapidConvertUtils.getInstance().lookup (Date.class);
            Date date = defaultVlue?converter.formater.parse (defaultVlue):new Date(0);
            return "new Date(${date.getTime()})";
        }
        else
        {
            return "\"$modelProperty.defaultValue\"";
        }
    }
}